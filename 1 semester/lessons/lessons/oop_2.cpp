#include <string>
//РЕАЛИЗАЦИЯ ООП В C++

//Объявление класса
//	public - видны всем(идеологически - интерфейс)
//	protect - видны потомкам и классу(интерфейс для потомков)
//	private - видны ___ другим классам?

//Реализация в программе
class A {
public:
	A();
	void doSmthng();
	//константная ф-я(метод) - не меняет значения полей класса, ибо константна, кэп.
	int getSmthng() const;
protected:
	int mField;
private:
	std::string mOlolo;
};

//Реализация в .cpp
/*A::A()
{
	mField = 0;
	mOlolo = 10;
}

void A::doSmthng()
{
	mField = 100;
}*/

//Наследование
class A{
public:
	//абстрактный метод
	virtual void f() = 0;
private:
	int mA;
};

class B:public A{
public:
	virtual void f() //переопределение метода
	{
		a = 10;
	}
};

//Пример использования
int main()
{
	A *object = new B();
	object->f();
}

//~~~ virtual и overwrite

//Конструктор
//	это спец. метод
//	инициализирует нач.состояние объекта
//	виды: 
//		конструктор по умолчанию
//		конструктор копирования
//		все остальные


//Деструктор
//	лучше писать через virtual чтобы при объекте времени выполнения - потомка
//	(а компиляции - предка) вызывался именно перегруженный деструктор потомка.

//Виртуальный метод