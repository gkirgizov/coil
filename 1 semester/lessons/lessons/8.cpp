typedef int MyType;

void main()
{
//ДЕРЕВЬЯ
	//Прямой порядок обхода
	//	посещаем корень, потом его сыновей, а для каждого сына тут же рекусрвиный вызов вышесказанного
	//Обратный порядок  обхода
	//	сначала сыновья потом корень - и рекурсия
	//Внутренний порядок обхода
	//	сын--корень всегда идет за первым сыном--остальные сыны

	//Представление в виде массива
	//~сортировка кучей
	//~алгоритм Хаффмана: применение двоичных деревьев
	
	//САМОБАЛАНСИРУЮЩИЕСЯ ДЕРЕВЬЯ
	//у которых разница высот левого и правого поддерева не более единицы
	//~AWL - деревья (АВЛ)
	//в узле дополнительно хранится значение разницы высоты между левым и правым поддеревьями (баланс)
	//
	//Баланс считается на обратном проходе после добавления.
	//переупорядочиваем: выполняем поворот.


//СПИСКИ НА МАССИВАХ
	//в струтуре списка - массив(макс размер списка) и индекс

// ССЫЛКИ И УКАЗАТЕЛИ
	// (*&) - указатель на ссылку (компилятор наверное не поймет)
	// (&*) - ссылка на указатель
	// (*) указатель - сущность
//	водится)


//ДВОИЧНОЕ ПРЕДСТАВЛЕНИЕ
	//чтобы получить i - й бит числа  мы формируем вспомголтаельное число
	//в котором на i - м месте будет бит
	//должны логически поэндить
	//и сравнить с нулем

	int mask = 1;
	bool ithBit = a & (mask << i) != 0;


//ОПЕРАТОРЫ ПРИВЕДЕНИЯ ТИПОВ
	//Разница с преобразованием классов.
	//бросит исключение при некоторых условиях
	static_cast<MyType>(a);
	//бросит nullptr
	dynamic_cast<MyType>(a);
	//просто переобозначит область памяти
	reinterpret_cast<MyType>(a);
}