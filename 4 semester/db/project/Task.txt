Учет дефектов при разработке программного обеспечения

·Контора «SuperSoft» разрабатывает программное обеспечение
·В штате конторы много сотрудников. У каждого сотрудника есть ФИО, рабочий email account, уникальный идентификационный номер и его амплуа: программист, тестер или руководитель проектов
·В разработке одновременно находятся много проектов. У каждого проекта имеется название, дата начала и предполагаемая дата завершения
·В каждом проекте заняты руководитель проекта и некоторое количество программистов и тестеров. И руководители, и программисты и тестеры могут одновременно участвовать в нескольких разных проектах, деля свое рабочее время по проектам в каком-то процентном соотношении – например, 80% времени программист уделяет одному проекту и 20% времени другому.
·Для каждого проекта ведется учет задач (issue tracking). Задача – это либо реализация какой-то новой функциональности (feature), либо обнаруженный в имеющейся функциональности дефект (bug).
·Задачу может создать любой участник проекта. При создании задаче присваивается уникальный номер, делается краткий заголовок (title) и подробное описание (description). Впоследствии назначаются ответственный за решение задачи программист и ответственный за ее проверку тестер
·Каждый день каждый проект делает новую сборку (build) разрабатываемого продукта. У каждой сборки есть свой номер
·У задачи есть статус: «открыта», «решена», «проверена» и со статусом связан номер сборки, в которой этот статус присвоен. Например, если тестер обнаруживает в сборке 325 новый дефект, то он создает соответствующую задачу и отмечает, что ей присвоен статус «открыта» в сборке 325. Через несколько дней программист исправляет дефект и отмечает что в сборке 330 задача «решена». Еще через несколько дней тестер проверяет исправление и если все в порядке, то отмечает что в сборке 333 задача «проверена», а если же проблема все-таки воспроизводится, то отмечает, что в сборке 333 задача «открыта»
·У задач есть приоритеты: A, B и C. Задачи с приоритетом A (must have) обязательно должны быть решены и проверены к моменту выпуска продукта, в то время как задачи с приоритетом B или C могут быть и не решены к этому моменту
·Каждый дефект относится к одной или более фиче. Относится в смысле «не было бы этих фич – не было бы и этих дефектов»
 
Запросы

1.    Найти список открытых багов в заданном проекте и ответственных за их исправление программистов
2.    Если выкинуть некоторые фичи, то исчезнут некоторые баги.
Найти множество фич, которые можно выкинуть для того чтоб исчезли все баги и потом найти множество фич, которые после этого останутся в проекте
3.    Найти по состоянию на сборку номер N все "переоткрытые" задачи, то есть такие, которые находятся в состоянии "открыта", но в какой-то сборке ранее были в состоянии "решена"

Представления

1.    Как вы поняли, в багтрекере хранится история задач. Одна и та же задача в сборке номер 1 может быть открыта, в сборке номер 10 закрыта, а в сборке номер 12 снова открыта (потому что тестер, например, обнаружил что проблема не исправлена). Но для многих целей хочется знать актуальный статус задач (тот, который был присвоен ей в сборке, ближайшей к последней). Сделайте пожалуйста соответствующее представление
2.    Директору хочется знать, какие проекты близки к завершению, какие нет и какого руководителя за каждый проект поощрять или увольнять. Показатель завершенности проекта -- это процент закрытых фич и количество открытых багов. Сделайте для пана директора соответствующее представление
3.    Хороших программистов директор хочет поощрить. Хорошими он считает тех, кто закрыл больше багов, чем среднее количество закрытых багов на программиста (это ненормальный критерий, но никто не утверждает, что у нас идеальная контора). Сделайте директору представление, которое выдаст ему список хороших программистов и для каждого из них -- число закрытых багов 

Хранимая процедура
 
1.    Вам хочется знать, как скоро проект завершится. Завершится он тогда, когда не будет открытых багов (мы предполагаем, что фичи уже все закрыты). Для этого вы используете простую линейную экстраполяцию скорости закрытия багов и появления новых. Берете некоторую точку начала (можно считать это параметром), считаете сколько багов было закрыто от нее и до текущего момента и сколько появилось новых. Делите это на длину отрезка времени -- получаете скорость. Решаете несложное уравнение и печатаете ответ.